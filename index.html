(() => {
  const $ = (sel, root=document) => root.querySelector(sel);

  function showError(msg){
    const box = $("#runtimeError");
    box.style.display = "block";
    box.textContent = msg;
  }

  try {
    const BUILD = new Date().toISOString().slice(0,19).replace("T"," ");
    $("#buildStamp").textContent = `build ${BUILD}`;

    /* ====== Constants ====== */
    const DICE = ["d4","d6","d8","d10","d12"];
    const DICE_IDX = {"d4":0,"d6":1,"d8":2,"d10":3,"d12":4};

    const ATTRS = ["Agility","Smarts","Spirit","Strength","Vigor"];

    // Common Knowledge removed; Riding is core (starts at d4 free).
    const SKILLS = [
      {name:"Academics", linked:"Smarts"},
      {name:"Athletics", linked:"Agility", core:true},
      {name:"Battle", linked:"Smarts"},
      {name:"Boating", linked:"Agility"},
      {name:"Driving", linked:"Agility"},
      {name:"Faith", linked:"Spirit"},
      {name:"Fighting", linked:"Agility"},
      {name:"Gambling", linked:"Smarts"},
      {name:"Healing", linked:"Smarts"},
      {name:"Intimidation", linked:"Spirit"},
      {name:"Language", linked:"Smarts"},
      {name:"Notice", linked:"Smarts", core:true},
      {name:"Occult", linked:"Smarts"},
      {name:"Performance", linked:"Spirit"},
      {name:"Persuasion", linked:"Spirit", core:true},
      {name:"Repair", linked:"Smarts"},
      {name:"Research", linked:"Smarts"},
      {name:"Riding", linked:"Agility", core:true},
      {name:"Science", linked:"Smarts"},
      {name:"Shooting", linked:"Agility"},
      {name:"Stealth", linked:"Agility", core:true},
      {name:"Survival", linked:"Smarts"},
      {name:"Taunt", linked:"Smarts"},
      {name:"Thievery", linked:"Agility"}
    ];

    // IMPORTANT: starter list only (you can load your full list via the loader below).
    const STARTER_HINDRANCES = [
      {name:"All Thumbs", type:"Minor", summary:"Clumsy with devices; penalties apply."},
      {name:"Arrogant", type:"Minor", summary:"Overconfident; may create trouble."},
      {name:"Bad Eyes", type:"Minor/Major", summary:"Impaired vision; severity varies."},
      {name:"Bloodthirsty", type:"Major", summary:"Prefers lethal solutions."},
      {name:"Cautious", type:"Minor", summary:"Hesitates; avoids risk."},
      {name:"Curious", type:"Major", summary:"Compelled to investigate."},
      {name:"Enemy", type:"Minor/Major", summary:"Has an enemy; severity varies."},
      {name:"Greedy", type:"Minor/Major", summary:"Desires wealth; severity varies."},
      {name:"Habit", type:"Minor/Major", summary:"Addictive habit; severity varies."},
      {name:"Illiterate", type:"Minor", summary:"Cannot read."},
      {name:"Loyal", type:"Minor", summary:"Sticks by allies/cause."},
      {name:"Mean", type:"Minor", summary:"Antagonistic; worsens social interactions."},
      {name:"Pacifist", type:"Minor/Major", summary:"Avoids violence; severity varies."},
      {name:"Phobia", type:"Minor/Major", summary:"Fear trigger; severity varies."},
      {name:"Stubborn", type:"Minor", summary:"Digs in; resists compromise."},
      {name:"Vow", type:"Minor/Major", summary:"Binding vow; severity varies."},
      {name:"Wanted", type:"Minor/Major", summary:"Sought by law/others; severity varies."}
    ];

    const LS_KEY_HINDS = "swade_oldwest_hindrances_v1";

    /* ====== Helpers ====== */
    const clampInt = (v, lo, hi) => {
      let n = parseInt(v||"0",10); if(Number.isNaN(n)) n=0;
      return Math.max(lo, Math.min(hi, n));
    };
    const dieCostFromD4 = (d) => (DICE_IDX[d] ?? 0);

    const rankFromAdv = (adv) => {
      if(adv>=16) return "Legendary";
      if(adv>=12) return "Heroic";
      if(adv>=8) return "Veteran";
      if(adv>=4) return "Seasoned";
      return "Novice";
    };

    // Skill cost: core skills start at d4 free; others start untrained free.
    // Steps up to linked: 1. Above linked: 2.
    function skillCost(skillDie, linkedDie, isCore){
      if(!skillDie) return 0;
      const sIdx = DICE_IDX[skillDie];
      const lIdx = DICE_IDX[linkedDie] ?? 0;
      const basePaidIdx = isCore ? 0 : -1;
      let cost = 0;
      for(let idx = basePaidIdx + 1; idx <= sIdx; idx++){
        if(isCore && idx===0) continue;
        cost += (idx <= lIdx) ? 1 : 2;
      }
      return cost;
    }

    /* ====== State ====== */
    const state = {
      name:"",
      concept:"",
      race:"Human",
      advances:0,

      attrs: Object.fromEntries(ATTRS.map(a=>[a,"d4"])),
      skills: Object.fromEntries(SKILLS.map(s=>[s.name, s.core ? "d4" : ""])),

      hindRows: [
        {name:"", severity:"Minor"}, // severity only used when type is Minor/Major
        {name:"", severity:"Minor"},
        {name:"", severity:"Minor"}
      ],
      buyAttr:0,
      buySkill:0,
      buyEdge:0,
      buyFunds:0,

      // Edges as text entries with source
      edges: [
        {source:"Race", name:"(Human Adaptable: choose 1 Novice Edge)", locked:true},
      ]
    };

    /* ====== Hindrance list ====== */
    let hindList = [];

    function loadHindList(){
      hindList = [];
      const raw = localStorage.getItem(LS_KEY_HINDS);
      if(raw){
        try{
          const parsed = JSON.parse(raw);
          if(Array.isArray(parsed) && parsed.length) hindList = parsed;
        }catch{/* ignore */}
      }
      if(!hindList.length) hindList = STARTER_HINDRANCES.slice();
    }
    function saveHindList(){
      localStorage.setItem(LS_KEY_HINDS, JSON.stringify(hindList));
    }
    function hindByName(name){ return hindList.find(h=>h.name===name) || null; }

    /* ====== Rendering ====== */
    function renderCharacter(){
      $("#secCharacter").innerHTML = `
        <h2>Character</h2>
        <div class="row">
          <div><label>Name <input id="name" value="${esc(state.name)}"></label></div>
          <div><label>Concept <input id="concept" value="${esc(state.concept)}"></label></div>
          <div>
            <label>Race
              <select id="race">
                <option value="Human"${state.race==="Human"?" selected":""}>Human (Adaptable: 1 free Novice Edge)</option>
              </select>
            </label>
          </div>
        </div>
        <div class="row2">
          <div>
            <label>Advances <input type="number" id="advances" min="0" value="${state.advances}"></label>
            <div class="kpis">
              <span class="pill">Rank: <span class="mono" id="rank">${rankFromAdv(state.advances)}</span></span>
            </div>
          </div>
          <div class="muted" style="font-size:13px;line-height:1.35">
            Current scope: budgets + legality + save/load + printable layout. Full edge prerequisites and advancement legality come after.
          </div>
        </div>
      `;
    }

    function renderAttributes(){
      const rows = ATTRS.map(a => `
        <tr>
          <td><b>${a}</b></td>
          <td>
            <select class="attrSel" data-attr="${a}">
              ${DICE.map(d=>`<option value="${d}"${state.attrs[a]===d?" selected":""}>${d}</option>`).join("")}
            </select>
          </td>
          <td class="mono" id="attrCost_${safeId(a)}">0</td>
        </tr>
      `).join("");
      $("#secAttributes").innerHTML = `
        <h2>Attributes</h2>
        <table>
          <thead><tr><th>Attribute</th><th style="width:140px;">Die</th><th style="width:160px;">Cost</th></tr></thead>
          <tbody>${rows}</tbody>
        </table>
        <div class="kpis">
          <span class="pill">Attribute Spent: <span class="mono" id="attrSpent">0</span> / <span class="mono" id="attrBudget">5</span></span>
          <span class="pill">Status: <span class="mono" id="attrStatus">OK</span></span>
        </div>
      `;
    }

    function renderSkills(){
      const rows = SKILLS.map(s => {
        const val = state.skills[s.name] ?? "";
        const opts = [`<option value=""></option>`].concat(
          DICE.map(d=>`<option value="${d}"${val===d?" selected":""}>${d}</option>`)
        ).join("");
        return `
          <tr>
            <td>${s.core ? "◇ " : ""}${s.name}</td>
            <td class="mono">${s.linked}</td>
            <td><select class="skillSel" data-skill="${escAttr(s.name)}">${opts}</select></td>
            <td class="mono" id="skillCost_${safeId(s.name)}">0</td>
            <td class="muted">${s.core ? "Core: starts at d4 free" : ""}</td>
          </tr>
        `;
      }).join("");
      $("#secSkills").innerHTML = `
        <h2>Skills</h2>
        <div class="muted" style="font-size:13px;line-height:1.35;margin-bottom:8px">
          Old West house rules: <b>Common Knowledge removed</b>. Core skills starting at <b>d4 free</b>:
          <b>Athletics, Notice, Persuasion, Stealth, Riding</b>.
        </div>
        <table>
          <thead><tr><th>Skill</th><th style="width:120px;">Linked</th><th style="width:140px;">Die</th><th style="width:140px;">Cost</th><th>Notes</th></tr></thead>
          <tbody>${rows}</tbody>
        </table>
        <div class="kpis">
          <span class="pill">Skill Spent: <span class="mono" id="skillSpent">0</span> / <span class="mono" id="skillBudget">12</span></span>
          <span class="pill">Status: <span class="mono" id="skillStatus">OK</span></span>
        </div>
      `;
    }

    function renderHindrances(){
      const hindOptions = ['<option value=""></option>'].concat(
        hindList.map(h=>`<option value="${escAttr(h.name)}">${esc(h.name)}</option>`)
      ).join("");

      const rows = state.hindRows.map((r, i) => `
        <tr>
          <td>
            <select class="hindSel" data-i="${i}">
              ${hindOptions}
            </select>
          </td>
          <td class="mono" id="hindType_${i}">—</td>
          <td>
            <div id="hindSum_${i}">—</div>
            <div class="hint" id="hindSevWrap_${i}" style="display:none;margin-top:6px">
              Severity for Minor/Major:
              <select class="hindSev" data-i="${i}" style="max-width:160px">
                <option value="Minor">Minor</option>
                <option value="Major">Major</option>
              </select>
            </div>
          </td>
          <td class="mono" id="hindPts_${i}">0</td>
        </tr>
      `).join("");

      $("#secHindrances").innerHTML = `
        <h2>Hindrances (max 4 points)</h2>
        <table>
          <thead><tr><th style="width:38%;">Hindrance</th><th style="width:14%;">Type</th><th>Summary</th><th style="width:10%;">Pts</th></tr></thead>
          <tbody>${rows}</tbody>
        </table>

        <div class="kpis">
          <span class="pill">Hindrance Points: <span class="mono" id="hindPtsTot">0</span> / 4</span>
          <span class="pill">Spent: <span class="mono" id="hindSpent">0</span></span>
          <span class="pill">Remaining: <span class="mono" id="hindRemain">0</span></span>
          <span class="pill">Status: <span class="mono" id="hindStatus">OK</span></span>
        </div>

        <h3 style="margin:14px 0 8px;font-size:14px;">Spend Hindrance Points</h3>
        <div class="row4">
          <div>
            <label>+1 Attribute (cost 2)
              <input id="buyAttr" type="number" min="0" max="2" value="${state.buyAttr}">
            </label>
            <div class="hint">Adds <span class="mono">+2</span> attribute points per purchase.</div>
          </div>
          <div>
            <label>+1 Skill point (cost 1)
              <input id="buySkill" type="number" min="0" max="4" value="${state.buySkill}">
            </label>
            <div class="hint">Adds <span class="mono">+1</span> skill point per purchase.</div>
          </div>
          <div>
            <label>+1 Edge (cost 2)
              <input id="buyEdge" type="number" min="0" max="2" value="${state.buyEdge}">
            </label>
            <div class="hint">Creates Hindrance-sourced Edge slots below.</div>
          </div>
          <div>
            <label>+2× Starting Funds (cost 1)
              <input id="buyFunds" type="number" min="0" max="4" value="${state.buyFunds}">
            </label>
            <div class="hint">Counted for legality now; funds module later.</div>
          </div>
        </div>

        <div class="hint" style="margin-top:10px">
          Mechanical effects are not auto-applied yet; only legality + budgets.
        </div>
      `;

      // set selected values after DOM exists
      state.hindRows.forEach((r,i)=>{
        const sel = $(`.hindSel[data-i="${i}"]`);
        sel.value = r.name || "";
        const sev = $(`.hindSev[data-i="${i}"]`);
        sev.value = r.severity || "Minor";
      });
    }

    function renderEdges(){
      // Ensure we have enough “Hindrance” slots based on buyEdge
      const needHindSlots = state.buyEdge;
      syncHindranceEdgeSlots(needHindSlots);

      const rows = state.edges.map((e, idx) => `
        <tr>
          <td class="mono">${esc(e.source)}</td>
          <td>
            <input data-edge-idx="${idx}" class="edgeName" value="${esc(e.name)}" ${e.locked ? "disabled" : ""}>
          </td>
        </tr>
      `).join("");

      $("#secEdges").innerHTML = `
        <h2>Edges (with sources)</h2>
        <div class="hint">
          Race edge is always present. Hindrance Edge slots are created by spending Hindrance points on “+1 Edge”.
          (Advance-derived edges will be added in Stage D.)
        </div>
        <table>
          <thead><tr><th style="width:160px;">Source</th><th>Edge</th></tr></thead>
          <tbody>${rows}</tbody>
        </table>
        <div class="kpis">
          <span class="pill">Edge slots shown: <span class="mono" id="edgeSlots">${state.edges.length}</span></span>
          <span class="pill">Hindrance Edge slots: <span class="mono">${state.buyEdge}</span></span>
        </div>
      `;
    }

    function renderStatus(){
      $("#secStatus").innerHTML = `
        <h2>Status</h2>
        <div id="statusBox" class="status ok">OK</div>
      `;
    }

    function renderHindLoader(){
      $("#secHindLoader").innerHTML = `
        <h2>Hindrance List Loader</h2>
        <div class="hint">
          Paste your own full list (from your book) as lines like:<br>
          <span class="mono">Name | Minor</span> or <span class="mono">Name | Major</span> or <span class="mono">Name | Minor/Major</span><br>
          Optional 3rd field summary: <span class="mono">Name | Minor/Major | summary</span><br>
          Stored in your browser.
        </div>
        <label>Paste Hindrances Here
          <textarea id="hindImport" class="small" placeholder="All Thumbs | Minor | ...&#10;Wanted | Minor/Major | ..."></textarea>
        </label>
        <div class="kpis">
          <button id="btnLoadHinds" type="button">Load Hindrance List</button>
          <button id="btnResetHinds" type="button">Reset to Starter List</button>
          <span class="pill">Loaded: <span class="mono" id="hindCount">${hindList.length}</span></span>
        </div>
      `;
    }

    function esc(s){ return (s??"").toString().replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;"); }
    function escAttr(s){ return (s??"").toString().replaceAll('"',"&quot;"); }
    function safeId(s){ return (s??"").toString().replaceAll(" ","_").replaceAll("/","_"); }

    /* ====== Edges slot sync ====== */
    function syncHindranceEdgeSlots(n){
      // keep first edge row as Race locked
      const fixed = state.edges.filter(e => e.source==="Race");
      const hind = state.edges.filter(e => e.source==="Hindrance");
      const others = state.edges.filter(e => e.source!=="Race" && e.source!=="Hindrance");

      while(hind.length < n) hind.push({source:"Hindrance", name:"", locked:false});
      while(hind.length > n) hind.pop();

      state.edges = [...fixed, ...hind, ...others];
    }

    /* ====== Computation ====== */
    function hindPointsForRow(def, severity){
      if(!def) return 0;
      if(def.type==="Minor") return 1;
      if(def.type==="Major") return 2;
      if(def.type==="Minor/Major") return (severity==="Major") ? 2 : 1;
      return 0;
    }

    function hindSpendTotal(){
      return (2*state.buyAttr) + (1*state.buySkill) + (2*state.buyEdge) + (1*state.buyFunds);
    }

    function compute(){
      // Hindrance display + tally
      let hindPts = 0;
      for(let i=0;i<3;i++){
        const row = state.hindRows[i];
        const def = row.name ? hindByName(row.name) : null;

        const typeEl = $(`#hindType_${i}`);
        const sumEl  = $(`#hindSum_${i}`);
        const ptsEl  = $(`#hindPts_${i}`);
        const sevWrap = $(`#hindSevWrap_${i}`);

        if(!def){
          if(typeEl) typeEl.textContent = "—";
          if(sumEl) sumEl.textContent = "—";
          if(ptsEl) ptsEl.textContent = "0";
          if(sevWrap) sevWrap.style.display = "none";
          continue;
        }

        if(typeEl) typeEl.textContent = def.type;
        if(sumEl) sumEl.textContent = def.summary || "";
        if(sevWrap) sevWrap.style.display = (def.type==="Minor/Major") ? "block" : "none";

        const pts = hindPointsForRow(def, row.severity || "Minor");
        if(ptsEl) ptsEl.textContent = String(pts);
        hindPts += pts;
      }

      const spent = hindSpendTotal();
      const remain = hindPts - spent;

      if($("#hindPtsTot")) $("#hindPtsTot").textContent = String(hindPts);
      if($("#hindSpent")) $("#hindSpent").textContent = String(spent);
      if($("#hindRemain")) $("#hindRemain").textContent = String(remain);

      const hindOk = (hindPts <= 4) && (spent <= hindPts);
      if($("#hindStatus")){
        $("#hindStatus").textContent = hindOk ? "OK" : "ILLEGAL";
        $("#hindStatus").className = "mono " + (hindOk ? "ok" : "bad");
      }

      // Budgets
      const attrBudget = 5 + (2 * state.buyAttr);
      const skillBudget = 12 + (1 * state.buySkill);

      // Attributes spent
      let attrSpent = 0;
      for(const a of ATTRS){
        const c = dieCostFromD4(state.attrs[a]);
        attrSpent += c;
        const el = $(`#attrCost_${safeId(a)}`);
        if(el) el.textContent = String(c);
      }
      if($("#attrSpent")) $("#attrSpent").textContent = String(attrSpent);
      if($("#attrBudget")) $("#attrBudget").textContent = String(attrBudget);
      const attrOk = attrSpent <= attrBudget;
      if($("#attrStatus")){
        $("#attrStatus").textContent = attrOk ? "OK" : "ILLEGAL";
        $("#attrStatus").className = "mono " + (attrOk ? "ok" : "bad");
      }

      // Skills spent
      let skillSpent = 0;
      for(const s of SKILLS){
        const sd = state.skills[s.name] || "";
        const ld = state.attrs[s.linked];
        const c = skillCost(sd, ld, !!s.core);
        skillSpent += c;
        const el = $(`#skillCost_${safeId(s.name)}`);
        if(el) el.textContent = String(c);
      }
      if($("#skillSpent")) $("#skillSpent").textContent = String(skillSpent);
      if($("#skillBudget")) $("#skillBudget").textContent = String(skillBudget);
      const skillOk = skillSpent <= skillBudget;
      if($("#skillStatus")){
        $("#skillStatus").textContent = skillOk ? "OK" : "ILLEGAL";
        $("#skillStatus").className = "mono " + (skillOk ? "ok" : "bad");
      }

      // Overall status
      const issues = [];
      if(hindPts > 4) issues.push(`Hindrances exceed 4 points (you have ${hindPts}).`);
      if(spent > hindPts) issues.push(`Hindrance spending exceeds points earned (spent ${spent}, earned ${hindPts}).`);
      if(!attrOk) issues.push(`Attributes overspent: ${attrSpent}/${attrBudget}.`);
      if(!skillOk) issues.push(`Skills overspent: ${skillSpent}/${skillBudget}.`);

      const sb = $("#statusBox");
      if(sb){
        if(issues.length===0){
          sb.textContent = "OK";
          sb.className = "status ok";
        }else{
          sb.innerHTML = `<span class="bad">ILLEGAL</span><div class="muted" style="margin-top:6px">${issues.join(" ")}</div>`;
          sb.className = "status bad";
        }
      }

      // Rank display
      if($("#rank")) $("#rank").textContent = rankFromAdv(state.advances);

      // Edge slots count display
      const edgeSlots = $("#edgeSlots");
      if(edgeSlots) edgeSlots.textContent = String(state.edges.length);
    }

    /* ====== Save / Load ====== */
    function serialize(){
      return {
        v: 1,
        swade: "Old West",
        ...state,
      };
    }

    function hydrate(obj){
      if(!obj || typeof obj !== "object") return;
      state.name = obj.name ?? "";
      state.concept = obj.concept ?? "";
      state.race = obj.race ?? "Human";
      state.advances = clampInt(obj.advances ?? 0, 0, 50);

      // attrs
      if(obj.attrs && typeof obj.attrs==="object"){
        for(const a of ATTRS){
          const v = obj.attrs[a];
          if(DICE.includes(v)) state.attrs[a] = v;
        }
      }
      // skills
      if(obj.skills && typeof obj.skills==="object"){
        for(const s of SKILLS){
          const v = obj.skills[s.name];
          state.skills[s.name] = (v==="" || DICE.includes(v)) ? v : state.skills[s.name];
        }
      }
      // hindrances
      if(Array.isArray(obj.hindRows) && obj.hindRows.length===3){
        state.hindRows = obj.hindRows.map(r=>({
          name: (r && r.name) ? String(r.name) : "",
          severity: (r && (r.severity==="Major")) ? "Major" : "Minor"
        }));
      }
      // buys
      state.buyAttr = clampInt(obj.buyAttr ?? 0, 0, 2);
      state.buySkill = clampInt(obj.buySkill ?? 0, 0, 4);
      state.buyEdge = clampInt(obj.buyEdge ?? 0, 0, 2);
      state.buyFunds = clampInt(obj.buyFunds ?? 0, 0, 4);

      // edges: preserve race locked row; load others if present
      if(Array.isArray(obj.edges)){
        const raceRow = state.edges.find(e=>e.source==="Race") || {source:"Race", name:"(Human Adaptable: choose 1 Novice Edge)", locked:true};
        const rest = obj.edges
          .filter(e => e && e.source !== "Race")
          .map(e => ({source: String(e.source||"Manual"), name: String(e.name||""), locked: false}));
        state.edges = [raceRow, ...rest];
      } else {
        state.edges = [{source:"Race", name:"(Human Adaptable: choose 1 Novice Edge)", locked:true}];
      }
    }

    function downloadJSON(){
      const data = JSON.stringify(serialize(), null, 2);
      const blob = new Blob([data], {type:"application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `${(state.name||"character").replaceAll(" ","_")}_SWADE_Old_West.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function handleLoadFile(file){
      const reader = new FileReader();
      reader.onload = () => {
        try{
          const obj = JSON.parse(String(reader.result||""));
          hydrate(obj);
          renderAll();
        }catch(e){
          alert("Could not load JSON: " + (e && e.message ? e.message : String(e)));
        }
      };
      reader.readAsText(file);
    }

    /* ====== Hindrance loader parsing ====== */
    function parseHindImport(text){
      const lines = (text||"").split("\n").map(l=>l.trim()).filter(Boolean);
      const out = [];
      for(const line of lines){
        const parts = line.split("|").map(p=>p.trim());
        if(parts.length < 2) continue;
        const name = parts[0];
        const type = parts[1];
        const summary = parts[2] || "";
        if(!name) continue;
        out.push({name, type, summary});
      }
      const okTypes = new Set(["Minor","Major","Minor/Major"]);
      return out.filter(h => okTypes.has(h.type));
    }

    /* ====== Wire events ====== */
    function wireEvents(){
      $("#btnPrint").addEventListener("click", ()=>window.print());
      $("#btnSave").addEventListener("click", downloadJSON);
      $("#fileLoad").addEventListener("change", (e)=>{
        const f = e.target.files && e.target.files[0];
        if(f) handleLoadFile(f);
        e.target.value = "";
      });

      document.addEventListener("input", (e)=>{
        const t = e.target;
        if(!t) return;

        if(t.id==="name"){ state.name = t.value; }
        if(t.id==="concept"){ state.concept = t.value; }

        if(t.id==="advances"){ state.advances = clampInt(t.value,0,50); }

        if(t.id==="buyAttr"){ state.buyAttr = clampInt(t.value,0,2); renderEdges(); wireEdgeInputs(); compute(); return; }
        if(t.id==="buySkill"){ state.buySkill = clampInt(t.value,0,4); }
        if(t.id==="buyEdge"){ state.buyEdge = clampInt(t.value,0,2); renderEdges(); wireEdgeInputs(); compute(); return; }
        if(t.id==="buyFunds"){ state.buyFunds = clampInt(t.value,0,4); }

        if(t.classList.contains("edgeName")){
          const idx = clampInt(t.getAttribute("data-edge-idx"),0,999);
          if(state.edges[idx] && !state.edges[idx].locked){
            state.edges[idx].name = t.value;
          }
        }

        compute();
      });

      document.addEventListener("change", (e)=>{
        const t = e.target;
        if(!t) return;

        if(t.id==="race"){
          state.race = t.value;
        }

        if(t.classList.contains("attrSel")){
          const a = t.getAttribute("data-attr");
          if(ATTRS.includes(a)) state.attrs[a] = t.value;
        }

        if(t.classList.contains("skillSel")){
          const sname = t.getAttribute("data-skill");
          if(sname in state.skills) state.skills[sname] = t.value;
        }

        if(t.classList.contains("hindSel")){
          const i = clampInt(t.getAttribute("data-i"),0,2);
          state.hindRows[i].name = t.value;
        }

        if(t.classList.contains("hindSev")){
          const i = clampInt(t.getAttribute("data-i"),0,2);
          state.hindRows[i].severity = t.value === "Major" ? "Major" : "Minor";
        }

        compute();
      });

      // Hindrance loader buttons
      $("#secHindLoader").addEventListener("click", (e)=>{
        const t = e.target;
        if(!t) return;

        if(t.id==="btnLoadHinds"){
          const parsed = parseHindImport($("#hindImport").value);
          if(!parsed.length){
            alert("No valid hindrances parsed. Use: Name | Minor/Major | optional summary");
            return;
          }
          hindList = parsed;
          saveHindList();
          renderAll(); // rebuild dropdowns
          alert(`Loaded ${hindList.length} hindrances into dropdowns.`);
        }

        if(t.id==="btnResetHinds"){
          hindList = STARTER_HINDRANCES.slice();
          saveHindList();
          renderAll();
          alert("Reset to starter hindrance list.");
        }
      });
    }

    function wireEdgeInputs(){
      // no special wiring needed beyond global input handler; this exists so we can call after re-render
    }

    function renderAll(){
      renderCharacter();
      renderAttributes();
      renderSkills();
      renderHindrances();
      renderEdges();
      renderStatus();
      renderHindLoader();
      compute();
    }

    /* ====== Init ====== */
    loadHindList();
    renderAll();
    wireEvents();

  } catch (err) {
    console.error(err);
    showError("Runtime error: " + (err && err.message ? err.message : String(err)));
  }

  // Basic HTML escaping used in render
  function esc(s){ return (s??"").toString().replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;"); }
})();
